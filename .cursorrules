# Project Rules for Nest-Haus Configurator

## Code Quality & Documentation
- Make sure to include the indexed documentations of the languages and tools we use when needed: React, Next.js, Prisma, Redis, PostgreSQL
- Always try to keep the codebase slim and the code you generate concise
- Don't change any content or design properties that are not directly related to a prompt, if unsure, always ask
- Documentation in /docs must be updated after every commit, using the predefined .md files and continuing them as needed
- Use GitHub Actions or equivalent CI to continuously generate and update documentation

## Development Workflow
- Check for existing running servers (localhost:3000) before running a new server, we have hot reload in place
- Fill out the documentation in /docs after every commit, use the predefined .md files and continue them
- Use GitHub actions to continuously document

## Terminal & PowerShell Guidelines
- **Python Access**: Python is installed via winget at standard Windows location
- **PowerShell Syntax**: Never use `&&` for command chaining (not supported in PowerShell)
- **Use PowerShell operators**: Use `;` for command separation or separate commands
- **Call external executables**: Use `&` operator: `& "path\to\executable.exe" args`
- **Path format**: Use Windows paths with backslashes or forward slashes
- **Package management**: Use `python -m pip install package` for Python packages
- **Example commands**:
  ```powershell
  # ‚úÖ Correct PowerShell syntax
  cd preiskalkulation; python read_prices.py
  python -m pip install pandas openpyxl
  & "C:\Program Files\Python\python.exe" --version
  
  # ‚ùå Incorrect (Unix-style, doesn't work in PowerShell)
  cd preiskalkulation && python read_prices.py
  ```

## Testing & CI
- All integration tests must be automated and run as part of the CI pipeline
- Integration tests should be cleaned up after execution to avoid redundant or stale test artifacts
- Test files, data, and temporary resources created during tests must be removed or reset after each test run
- Periodically review and remove obsolete or redundant tests to keep the test suite lean
- Ensure that test coverage is maintained without accumulating unnecessary or duplicate tests

## Architecture Constraints
- Backend tracking system (Redis + PostgreSQL) must remain intact for analytics
- Session management and analytics should not be disrupted but should be non-blocking
- Price calculations must be CLIENT-SIDE for instant response times
- State management should use the established store pattern (Zustand)
- API calls should be optimistic and fail-safe (don't block user experience)

## Integration Guidelines
- New configurator components must integrate with useConfiguratorStore and useCartStore
- User selections should be tracked via session APIs as background tasks (non-blocking)
- Cart functionality should remain compatible across the app
- Maintain backward compatibility during migrations
- Prioritize instant user feedback over server synchronization

## Folder Structure Rules (React/Next.js Best Practice)
- **Route-specific code** (components, types, hooks, data, core logic) must be co-located inside the relevant route folder under `src/app/ROUTE/`
- **Shared/global components** must be placed in `src/components/`
- **Shared hooks** must be placed in `src/hooks/`
- **Global state management** (e.g., Zustand stores) must be placed in `src/store/`
- **Service logic** (e.g., Prisma, Redis clients) must be placed in `src/lib/`
- **Shared types/interfaces** must be placed in `src/types/`
- **Shared constants** must be placed in `src/constants/`
- **Context providers** must be placed in `src/contexts/`
- **Do NOT place non-route files directly in `src/app/`**. Only route folders and route-specific files (e.g., `page.tsx`, `layout.tsx`) are allowed there
- **If a component is only used by a single route, keep it in that route's folder.** If it is used in multiple routes, move it to `src/components/`

## Performance & Rendering Strategy

### **Balanced SSR/Client Architecture**
**PRIORITY: Optimize for both SEO and User Experience**

#### SSR-First for Content Pages
- **Marketing pages, blogs, documentation**: Full SSR for SEO and Core Web Vitals
- **Landing pages and product pages**: Server-rendered with minimal client hydration
- **Static content**: Use static generation when possible

#### Client-First for Interactive Applications
- **Configurator and dynamic tools**: Client-side for instant feedback and complex state
- **User dashboards and forms**: Client-side for real-time validation and updates
- **Shopping cart and checkout**: Client-side for seamless user experience

#### Hybrid Pattern Implementation
```tsx
// ‚úÖ Page Router (SSR for SEO)
export default function ConfiguratorPage() {
  return <ConfiguratorClient />;
}

// ‚úÖ Client Component (Instant interactions)
'use client';
export default function ConfiguratorClient() {
  // Handle: real-time price updates, selections, state management
}
```

### **Client-Side Performance Rules**
- **Price calculations**: Always client-side for sub-100ms response times
- **Form validation**: Client-side with server confirmation
- **State updates**: Optimistic updates with background sync
- **API calls**: Non-blocking, fail-safe, with graceful degradation

### **Server-Side Integration**
- **Session tracking**: Background tasks that don't block UI
- **Data persistence**: Opportunistic saves without blocking user flow
- **Analytics**: Fire-and-forget tracking events

## Responsive Design Guidelines
- Use Tailwind and Medium's responsive design system in combination
- Prefer relative units (em, vh, vw) over fixed pixel sizes
- Set max-width of 1144px for descriptive content (e.g. navbar)
- No width restrictions for main site content
- Implement mobile view switch at 600-700px using window.innerWidth
- Detect mobile access and differentiate between WebKit (iOS) and Android
- Handle WebKit-specific requirements:
  - Hide address bar appropriately
  - Manage nested scrolling containers carefully due to WebKit limitations
- Use Tailwind's responsive classes for consistent breakpoint handling
- Implement fluid typography using clamp() for dynamic text sizing
- Ensure all interactive elements have minimum touch target size of 44x44px
- Test layouts across standard breakpoints (sm: 640px, md: 768px, lg: 1024px, xl: 1280px)
- Maintain aspect ratios for media content using aspect-ratio utility
- Use CSS Grid and Flexbox for responsive layouts instead of fixed dimensions

## Server-Side Rendering (SSR) & Client-Side Guidelines
**BALANCED APPROACH: SSR for content, Client-side for interactions**

### When to Use SSR (Server Components)
- **Static content pages**: About, services, blog posts
- **SEO-critical pages**: Landing pages, product showcases
- **Initial page loads**: For better Core Web Vitals
- **Content that doesn't change frequently**

### When to Use Client-Side ("use client")
- **Interactive applications**: Configurators, calculators, dynamic forms
- **Real-time features**: Live updates, instant feedback
- **Complex state management**: Multi-step processes, shopping carts
- **User-specific content**: Dashboards, personalized experiences
- **Third-party integrations**: Maps, analytics, chat widgets

### Image Optimization Guidelines
- **Vercel Blob Images**: Use server components with Next.js Image component for optimal performance
- **Static images**: Always use Next.js `Image` component with proper sizing
- **Dynamic images**: Server-render when possible, client-render only for user-uploaded content

### Performance Requirements
- **Static Generation**: Prefer static generation (`generateStaticParams`) for predictable content
- **Streaming**: Use React Suspense for progressive loading of server components
- **Client Bundle Size**: Keep under 250KB for interactive components
- **Response Times**: <100ms for price calculations, <300ms for form submissions

# DOM Features & Sizing (React/Next.js projects)
- For any DOM feature or sizing communication between layout and page (e.g., scroll handling, dynamic sizing), always use a React context to provide refs or state.
- Never use querySelector, getElementById, or direct DOM traversal for such communication.
- This context-based approach is the default and required for all such requirements in this project.

## Landing Page Image Handling Rules

**CRITICAL: Landing Page Images (src/app/page.tsx) ONLY**

When working with background images on the landing page, ALWAYS use this exact pattern:

### Required Structure:
```tsx
// Landing page specific image styling - applies to all 8 images
const landingImageStyle = {
  objectPosition: 'center center',
  transform: 'scale(1.05)',
  transformOrigin: 'center center',
};

// Section with 16:9 aspect ratio constraint
<section key={section.id} className="relative w-full overflow-hidden" style={{ aspectRatio: '16/9' }}>
  <div className="absolute inset-0 w-full h-full">
    <Image
      src={section.image}
      alt={section.h1}
      fill
      className="object-cover"
      style={landingImageStyle}
      unoptimized
      priority={section.id === 1}
    />
  </div>
</section>
```

### Rules:
- ‚úÖ ALWAYS maintain 16:9 aspect ratio using `style={{ aspectRatio: '16/9' }}` on section
- ‚úÖ ALWAYS use `unoptimized` prop (for future Vercel blob compatibility)
- ‚úÖ ALWAYS use component-level `landingImageStyle` object (not global CSS)
- ‚úÖ ALWAYS apply same styling to ALL 8 landing page images
- ‚úÖ NEVER add overlays unless specifically requested
- ‚ùå NEVER use `h-screen` on landing page sections (conflicts with 16:9)
- ‚ùå NEVER apply this pattern to other pages (konfigurator, etc.)

### Future-Proof:
This pattern works with any image source (current files or future Vercel blob URLs).

## Error Handling & Debugging Guidelines
- **Client-side errors**: Log to console in development, use error boundaries in production
- **API failures**: Always have fallback states, don't block user experience  
- **State synchronization**: Use optimistic updates with conflict resolution
- **Performance monitoring**: Track response times and bundle sizes
- **Debugging**: Use structured logging with emojis for easy identification (üöÄ üè™ üí∞ üîß)