# Project Rules for Nest-Haus Configurator

## Essential Project Rules

- keep the code slim and efficient, dont use fixed dimensions and static sizes, never change any design properties or specifications without asking if they are not in direct relation to the prompt.
  Make sure to not make unneccessary api calls, always ask yourself what the minimu amount of reasonable call to an api for a specific request is.
- global project rules

## Rule Documentation Structure

This project uses a modular rule system organized in `.mdc` files for better maintainability and Cursor integration:

### **üìã Development & Technical Rules**

**File**: `docs/development-rules.mdc`

- Code quality & documentation standards
- TypeScript & type safety requirements
- Testing & verification guidelines
- Terminal & PowerShell usage (Windows environment)
- Prisma database management
- API testing & debugging with cURL
- Git & line ending configuration
- Error handling & debugging patterns

### **üèóÔ∏è Architecture & Design Rules**

**File**: `docs/architecture-design-rules.mdc`

- Folder structure & organization (React/Next.js best practices)
- SectionRouter navigation architecture (mandatory for content pages)
- Responsive design guidelines
- DOM features & sizing patterns
- Landing page image handling (specific rules)

### **‚ö° Performance & Rendering Rules**

**File**: `docs/performance-rendering-rules.mdc`

- SSR vs Client-side rendering strategy
- Image optimization & handling system
- Performance requirements & monitoring
- Caching strategies (multi-level)
- Next.js configuration standards

### **üóÑÔ∏è Database & Backend Rules**

**File**: `docs/database-backend-rules.mdc`

- Architecture constraints & integration guidelines
- Session lifecycle management
- Prisma error handling patterns
- Race condition prevention
- Configurator architecture patterns
- State management with Zustand

## Quick Reference Commands

### Server Management

```bash
# Check if server is running
netstat -an | findstr :3000

# Start development server (background)
npm run dev
```

### Prisma Operations

```bash
# Regenerate client after schema changes
npx prisma generate

# Sync schema to database
npx prisma db push

# Test database connection
curl -s "http://localhost:3000/api/test/db"
```

### API Testing

```bash
# Basic API test
curl -s "http://localhost:3000/api/endpoint"

# Format JSON response
curl -s "http://localhost:3000/api/endpoint" | python -m json.tool
```

## Critical Patterns

### TypeScript Safety & Linting Rules

- **NEVER use `any` type** - always specify proper types or interfaces
- Use `unknown` over `any` when type is truly unknown
- Implement proper type guards and assertions
- **ALWAYS prefix unused parameters with underscore** (`_paramName`) to indicate intentional non-use
- **ALWAYS define explicit interfaces** for complex data structures instead of using `any`
- **ALWAYS type function parameters** - never leave them as implicit `any`
- **ALWAYS type reduce/map/filter callbacks** with proper type annotations
- **ALWAYS run `npm run lint` before committing** to catch TypeScript violations
- **NEVER ignore ESLint warnings** - fix them or add proper eslint-disable comments with justification

#### Specific Anti-Patterns to Avoid:
```typescript
// ‚ùå NEVER DO THIS:
function process(data: any) { ... }
const items = data.map((item: any) => ...)
function unused(param: string) { ... } // unused param without _

// ‚úÖ ALWAYS DO THIS:
interface DataItem { id: string; name: string; }
function process(data: DataItem[]) { ... }
const items = data.map((item: DataItem) => ...)
function unused(_param: string) { ... } // unused param with _
```

#### Critical TypeScript Patterns (Prevent Build Failures):

**1. Indexing Dynamic Objects**
```typescript
// ‚ùå WRONG - TypeScript can't infer index signature
const value = jsonObject[key];  // Error: can't index JsonValue

// ‚úÖ CORRECT - Explicit type assertion
const record = jsonObject as Record<string, unknown>;
const value = record[key];
```

**2. Empty Array Initialization**
```typescript
// ‚ùå WRONG - TypeScript infers never[]
const items = [];
items.push('string');  // Error: type 'string' not assignable to 'never'

// ‚úÖ CORRECT - Explicit type annotation
const items: string[] = [];
const items = [] as string[];
```

**3. Accessing Nested Properties on Unknown Types**
```typescript
// ‚ùå WRONG - TypeScript doesn't know if property exists
if (value.nested) { ... }  // Error: property doesn't exist on unknown

// ‚úÖ CORRECT - Type guard or assertion
if (typeof value === 'object' && value !== null && 'nested' in value) {
  const typed = value as { nested?: unknown };
  if (typed.nested) { ... }
}
```

**4. JSON Data from Prisma**
```typescript
// ‚ùå WRONG - Direct property access on JsonValue
const configValue = session.configurationData[key];

// ‚úÖ CORRECT - Cast to appropriate type first
const config = session.configurationData as Record<string, unknown>;
const configValue = config[key];
```

#### Interface Definition Requirements:
- Create interfaces for all API response types
- Create interfaces for all component prop types
- Create interfaces for all database query results
- Use proper typing for template literals and complex objects

#### Additional ESLint Compliance Rules:
- **Unused variables**: Remove or prefix with `_` if intentionally unused
- **Unused imports**: Remove unused imports immediately
- **Console statements**: Use proper logging or remove before production
- **Async/await**: Prefer async/await over Promise chains for readability
- **Error handling**: Always wrap async operations in try-catch blocks
- **Return types**: Explicitly type function return values when not obvious
- **React hooks**: Follow hooks rules (only call at top level, proper dependencies)

#### Code Quality Enforcement:
```typescript
// ‚úÖ GOOD: Proper error handling and typing
async function fetchUserData(userId: string): Promise<UserData | null> {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) return null;
    return await response.json() as UserData;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}

// ‚ùå BAD: No error handling, any types
async function fetchUserData(userId) {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
}
```

### Component Architecture

- Route-specific code stays in `src/app/ROUTE/`
- Shared components go in `src/components/`
- Use SectionRouter for all multi-section content pages

### Performance Priority

- Price calculations: CLIENT-SIDE (sub-100ms)
- Session tracking: Background, non-blocking
- API calls: Optimistic, fail-safe
- Images: Use `HybridBlobImage` with proper caching

### Database Operations

- Always use `upsert()` for session operations
- Handle race conditions and missing records gracefully
- Never block user experience waiting for database operations

---

**üìñ For detailed implementation guidelines, refer to the specific `.mdc` files listed above.**
