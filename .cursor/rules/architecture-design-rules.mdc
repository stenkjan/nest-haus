---
description: design specific rules for text and sizes
alwaysApply: false
---

# Architecture & Design Rules

## SEO-Conform Typography Standards (Updated 2025)

### **CRITICAL: Typography Color System**

Based on the comprehensive cleanup and heading optimization analysis, follow these rules:

#### **Heading Structure for SEO**

```tsx
// ✅ CORRECT: Semantic HTML with separate color classes
<h1 className="h1-primary text-gray-900 mb-3">Main Title</h1>
<h2 className="h2-title text-gray-900 mb-2">Section Title</h2>
<h3 className="h3-secondary text-gray-600 mb-8">Subtitle</h3>

// ❌ WRONG: Mixed concerns or hardcoded colors in base classes
<h1 className="h1-primary-dark">Title</h1> // Don't create color variants
```

#### **Typography Base Classes (No Colors)**

```css
/* Base classes define sizing, spacing, font-weight - NO COLORS */
.h1-primary {
  @apply font-bold text-3xl sm:text-3xl md:text-4xl lg:text-5xl xl:text-6xl mb-1 lg:mb-1.5;
}

.h2-title {
  @apply font-medium text-xl md:text-2xl lg:text-3xl xl:text-4xl 2xl:text-5xl;
}

.h3-secondary {
  @apply text-base font-medium sm:text-sm md:text-lg lg:text-xl xl:text-2xl mb-4;
}

.p-primary {
  @apply text-sm md:text-base lg:text-base xl:text-lg 2xl:text-xl leading-snug whitespace-pre-line;
}
```

#### **Color Application Strategy**

```tsx
// ✅ Background-based color selection
const getHeadingColors = (backgroundColor: 'white' | 'black' | 'gray') => ({
  title: backgroundColor === 'black' ? 'text-white' : 'text-gray-900',
  subtitle: backgroundColor === 'black' ? 'text-gray-300' : 'text-gray-600',
});

// Usage in components
<h1 className={`h1-primary ${titleColor} mb-3`}>Title</h1>
<h3 className={`h3-secondary ${subtitleColor} mb-8`}>Subtitle</h3>
```

### **Responsive Breakpoint System**

**CRITICAL**: Always use complete responsive breakpoint coverage:

```tsx
// ✅ CORRECT: Full responsive scale
"text-3xl md:text-4xl lg:text-5xl xl:text-6xl 2xl:text-7xl";

// ❌ WRONG: Incomplete breakpoints
"text-4xl md:text-[60px]"; // Missing lg, xl, 2xl
"text-3xl md:text-5xl"; // Missing lg, xl, 2xl
```

### **Standard Responsive Patterns**

#### **H1 (Main Title/Page Title)**

```tsx
"text-3xl md:text-4xl lg:text-5xl xl:text-6xl 2xl:text-6xl font-bold mb-2 md:mb-3";
// Font size progression: 30px → 36px → 48px → 60px → 72px
```

#### **H2 (Section Heading)**

```tsx
"text-lg md:text-xl lg:text-2xl xl:text-3xl 2xl:text-4xl";
// Font size progression: 18px → 20px → 24px → 30px → 36px
```

#### **H3 (Subtitle/Subheading)**

```tsx
"text-base md:text-lg lg:text-lg xl:text-xl 2xl:text-2xl";
// Font size progression: 16px → 18px → 18px (stays same) → 20px → 24px
```

#### **P (Body Text)**

```tsx
"text-sm md:text-base lg:text-base xl:text-lg 2xl:text-xl";
// Font size progression: 14px → 16px → 16px (stays same) → 18px → 20px
```

## Modular Component Architecture

### **CRITICAL: Modular Widget Development**

All new components and widgets must follow the modular, interchangeable approach:

#### **Component Structure Requirements**

```tsx
// ✅ CORRECT: Modular component with clear interfaces
interface ComponentProps {
  title?: string;
  subtitle?: string;
  backgroundColor?: "white" | "black" | "gray";
  showCards?: boolean;
  id?: string;
}

export function ModularComponent({
  title = "Default Title",
  subtitle = "Default Subtitle",
  backgroundColor = "white",
  showCards = true,
  id = "component-id",
}: ComponentProps) {
  const colors = getHeadingColors(backgroundColor);

  return (
    <section id={id} className={`w-full py-16 bg-${backgroundColor}`}>
      <div className="w-full max-w-[1536px] mx-auto px-4 sm:px-6 lg:px-8">
        <h2 className={`h1-primary ${colors.title} mb-3 text-center`}>
          {title}
        </h2>
        <h3 className={`h3-secondary ${colors.subtitle} mb-8 text-center`}>
          {subtitle}
        </h3>
        {showCards && <ComponentContent />}
      </div>
    </section>
  );
}
```

#### **Reusability Requirements**

- **Props Interface**: Always define clear TypeScript interfaces
- **Default Values**: Provide sensible defaults for all optional props
- **Background Adaptation**: Support white/black/gray backgrounds automatically
- **Content Flexibility**: Allow content to be toggled or customized
- **ID Support**: Always support custom IDs for navigation and testing

### **Grid Component Standards**

Follow the established grid component patterns:

```tsx
// ✅ Use existing grid components
<FullWidthTextGrid
  title="Section Title"
  subtitle="Section Subtitle"
  backgroundColor="black"
  content={gridContent}
/>

<ThreeByOneGrid
  title="Three Column Section"
  subtitle="Responsive grid layout"
  backgroundColor="white"
  cards={cardData}
/>

<ImageWithFourTextGrid
  title="Image + Text Grid"
  subtitle="Combined image and text content"
  backgroundColor="gray"
  imageData={imageConfig}
  textData={textContent}
/>
```

### **SectionRouter Configuration Rules**

#### Section Definition Requirements:

- ✅ **Unique IDs**: Each section must have a unique `id` that matches the HTML section element
- ✅ **SEO-friendly slugs**: Use kebab-case slugs that describe the content
- ✅ **Descriptive titles**: Clear, user-friendly titles for navigation
- ✅ **Logical ordering**: Sections should flow logically from top to bottom

#### Section Layout Standards:

**CRITICAL**: Follow the Section Standard defined in `/docs/TYPOGRAPHY_STANDARDS.md`

- ✅ **Standard padding**: Use `py-8 md:py-16` for vertical section padding (Mobile: 32px, Desktop: 64px)
- ✅ **Background colors**: Use `bg-white`, `bg-gray-50`, or `bg-black` explicitly
- ✅ **1536px max width**: Use `max-w-[1536px] mx-auto px-4 sm:px-6 lg:px-8` for content containers
- ✅ **Full width sections**: Always use `w-full` on section elements
- ✅ **Special patterns**: Hero sections, Media sections have documented exceptions (see Section Standard)

#### Navigation Behavior:

- ✅ **Automatic scroll**: SectionRouter handles smooth scrolling to sections
- ✅ **URL updates**: Browser URL updates with section slugs for bookmarkability
- ✅ **Mobile-friendly**: Touch and swipe navigation support
- ✅ **Keyboard accessible**: Arrow key navigation support

### **Content Structure Guidelines**

#### Section Header Pattern:

**RECOMMENDED**: Use the `SectionHeader` component for all section headers. See `/docs/TYPOGRAPHY_STANDARDS.md` for complete documentation.

```tsx
import { SectionHeader } from "@/components/sections";

<section id="section-id" className="w-full py-8 md:py-16 bg-white">
  <SectionHeader
    title="Section Title"
    subtitle="Section subtitle or description"
  />

  {/* Section content */}
  <div className="w-full max-w-[1536px] mx-auto px-4 sm:px-6 lg:px-8">
    {/* Your content components */}
  </div>
</section>;
```

**Standard Section Patterns:**

- **Standard Content Section**: `py-8 md:py-16` with SectionHeader (90% of sections)
- **Hero Section**: Custom padding (e.g., `md:pt-12 md:pb-4`) with custom layout
- **Media Section**: No padding (`w-full relative`) for full-width video/images
- **See Section Standard** in TYPOGRAPHY_STANDARDS.md for complete examples

#### Typography Consistency:

- ✅ **Use SectionHeader component**: Ensures consistent responsive typography
- ✅ **Follow Section Standard**: See TYPOGRAPHY_STANDARDS.md for all patterns
- ✅ **Semantic HTML**: Proper h1 → h2 → h3 hierarchy
- ✅ **Complete breakpoints**: All typography uses full responsive scale

### **Implementation Checklist**

#### Before Creating New Content Pages:

1. ✅ **Plan sections**: Define logical content sections and flow
2. ✅ **Create sections array**: Define IDs, titles, and slugs
3. ✅ **Implement PageClient**: Use SectionRouter wrapper pattern
4. ✅ **Add SEO metadata**: Include proper metadata in page.tsx
5. ✅ **Test navigation**: Verify smooth scrolling and URL updates
6. ✅ **Mobile testing**: Ensure touch navigation works properly

#### Quality Assurance:

- ✅ **Section IDs match**: HTML section IDs must match sections array IDs
- ✅ **Consistent styling**: All sections follow layout and typography rules
- ✅ **Responsive design**: Test on mobile, tablet, and desktop breakpoints
- ✅ **Accessibility**: Ensure keyboard navigation and screen reader compatibility
- ✅ **Performance**: Monitor loading times and smooth scrolling performance

### **DO/DON'T Rules**

#### ✅ DO:

- Use SectionRouter for all multi-section content pages
- Follow the exact implementation pattern shown above
- Maintain consistent section spacing and typography
- Test navigation thoroughly on all devices
- Use descriptive, SEO-friendly section slugs
- Implement proper metadata for each page
- Follow the 1536px max-width standard

#### ❌ DON'T:

- Skip SectionRouter for pages that could benefit from section navigation
- Use different layout patterns without architectural approval
- Hardcode navigation - always use SectionRouter component
- Ignore mobile touch navigation requirements
- Create sections without proper IDs or accessibility
- Mix different width constraints within the same page
- Forget to test URL bookmarking and sharing functionality

### **Future Page Planning**

When creating new content pages, always consider:

- **Will this page have multiple sections?** → Use SectionRouter
- **Could this page expand with more sections?** → Use SectionRouter proactively
- **Does this need section-based navigation?** → Use SectionRouter
- **Is this a utility/tool page?** → May not need SectionRouter (like konfigurator)

## Responsive Design Guidelines

- Use Tailwind and Medium's responsive design system in combination
- Prefer relative units (em, vh, vw) over fixed pixel sizes
- Set max-width of 1144px for descriptive content (e.g. navbar)
- No width restrictions for main site content
- Implement mobile view switch at 600-700px using window.innerWidth
- Detect mobile access and differentiate between WebKit (iOS) and Android
- Handle WebKit-specific requirements:
  - Hide address bar appropriately
  - Manage nested scrolling containers carefully due to WebKit limitations
- Use Tailwind's responsive classes for consistent breakpoint handling
- Implement fluid typography using clamp() for dynamic text sizing
- Ensure all interactive elements have minimum touch target size of 44x44px
- Test layouts across standard breakpoints (sm: 640px, md: 768px, lg: 1024px, xl: 1280px)
- Maintain aspect ratios for media content using aspect-ratio utility
- Use CSS Grid and Flexbox for responsive layouts instead of fixed dimensions

## DOM Features & Sizing (React/Next.js projects)

- For any DOM feature or sizing communication between layout and page (e.g., scroll handling, dynamic sizing), always use a React context to provide refs or state.
- Never use querySelector, getElementById, or direct DOM traversal for such communication.
- This context-based approach is the default and required for all such requirements in this project.

## Landing Page Image Handling Rules

**CRITICAL: Landing Page Images (src/app/page.tsx) ONLY**

When working with background images on the landing page, ALWAYS use this exact pattern:

### Required Structure:

```tsx
// Landing page specific image styling - applies to all 8 images
const landingImageStyle = {
  objectPosition: "center center",
  transform: "scale(1.05)",
  transformOrigin: "center center",
};

// Section with 16:9 aspect ratio constraint
<section
  key={section.id}
  className="relative w-full overflow-hidden"
  style={{ aspectRatio: "16/9" }}
>
  <div className="absolute inset-0 w-full h-full">
    <Image
      src={section.image}
      alt={section.h1}
      fill
      className="object-cover"
      style={landingImageStyle}
      unoptimized
      priority={section.id === 1}
    />
  </div>
</section>;
```

### Rules:

- ✅ ALWAYS maintain 16:9 aspect ratio using `style={{ aspectRatio: '16/9' }}` on section
- ✅ ALWAYS use `unoptimized` prop (for future Vercel blob compatibility)
- ✅ ALWAYS use component-level `landingImageStyle` object (not global CSS)
- ✅ ALWAYS apply same styling to ALL 8 landing page images
- ✅ NEVER add overlays unless specifically requested
- ❌ NEVER use `h-screen` on landing page sections (conflicts with 16:9)
- ❌ NEVER apply this pattern to other pages (konfigurator, etc.)

### Future-Proof:

This pattern works with any image source (current files or future Vercel blob URLs).
